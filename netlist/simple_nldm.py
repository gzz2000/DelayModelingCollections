# stores several LUTs from a simple cell library
# for demonstration of simultaneously solving net and cell
# delays.

# 1d/2d interpolation functions come directly from
# difftimer python ground truth.
def interpolate(f1, f2, x1, x2, x):
    if x1 == x2: return f1
    else: return ((x2 - x) * f1 + (x - x1) * f2) / (x2 - x1)

def apply_derate(vs, derate):
    return [v * derate for v in vs]

class LUT:
    def __init__(self, xs, ys, vs):
        self.xs = xs
        self.ys = ys
        self.vs = vs
        assert len(self.vs) == len(self.xs) * len(self.ys)

    def transpose(self):
        xs, ys = self.ys, self.xs
        vs = [0. for i in range(len(self.vs))]
        for i in range(len(xs)):
            for j in range(len(ys)):
                vs[i * len(ys) + j] = self.vs[j * len(xs) + i]
        return LUT(xs=xs, ys=ys, vs=vs)

    def lookup_grad(self, x, y):
        n = len(self.xs)
        m = len(self.ys)
        xi, xj, yi, yj = 0, 0, 0, 0
        if n > 1:
            while xi + 1 < n and self.xs[xi + 1] <= x: xi += 1
            xj = xi
            if xj + 1 < n: xj += 1
            else: xi -= 1
        if m > 1:
            while yi + 1 < m and self.ys[yi + 1] <= y: yi += 1
            yj = yi
            if yj + 1 < n: yj += 1
            else: yi -= 1
        def FT(i, j):
            return self.vs[i * m + j]
        def XT(i):
            return self.xs[i]
        def YT(j):
            return self.ys[j]
        rxi = interpolate(FT(xi, yi), FT(xi, yj), YT(yi), YT(yj), y)
        rxj = interpolate(FT(xj, yi), FT(xj, yj), YT(yi), YT(yj), y)
        ryi = interpolate(FT(xi, yi), FT(xj, yi), XT(xi), XT(xj), x)
        ryj = interpolate(FT(xi, yj), FT(xj, yj), XT(xi), XT(xj), x)
        r = interpolate(rxi, rxj, XT(xi), XT(xj), x)
        if abs(rxi - rxj) < 1e-10:
            dx = 0
        else:
            dx = (rxj - rxi) / (XT(xj) - XT(xi))
        if abs(ryi - ryj) < 1e-10:
            dy = 0
        else:
            dy = (ryj - ryi) / (YT(yj) - YT(yi))
        return r, dx, dy

    def lookup(self, x, y):
        return self.lookup_grad(x, y)[0]

# below LUTs are indexed by (output cap, input slew),
# per simple_Early.lib template definition.
inv_x1_az_cell_rise = LUT(
    xs=[0.00,1.00,2.00,4.00,8.00,16.00,32.00],
    ys=[5.00,30.00,50.00,80.00,140.00,200.00,300.00,500.00],
    vs=[
        9.376, 14.576, 18.136, 22.088, 27.856, 32.352, 38.568, 48.992,
        13.544, 18.744, 22.88, 27.96, 35.32, 40.944, 48.52, 60.664,
        17.704, 22.904, 27.064, 32.992, 41.784, 48.456, 57.336, 71.2,
        26.04, 31.24, 35.4, 41.64, 52.84, 61.408, 72.68, 89.872,
        42.704, 47.904, 52.064, 58.304, 70.784, 82.472, 97.92, 121.136,
        76.04, 81.24, 85.4, 91.64, 104.12, 116.6, 137.272, 170.648,
        142.704, 147.904, 152.064, 158.304, 170.784, 183.264, 204.064, 245.664
    ]
)

inv_x1_az_rise_trans = LUT(
    xs=[0.00,1.00,2.00,4.00,8.00,16.00,32.00],
    ys=[5.00,30.00,50.00,80.00,140.00,200.00,300.00,500.00],
    vs=[
        10, 10.976, 13.104, 16.08, 20.136, 22.92, 26.36, 31.864,
        15, 15.36, 16.92, 20.224, 25.72, 29.648, 34.384, 41.048,
        20, 20.072, 21.128, 23.928, 30.376, 35.272, 41.328, 49.488,
        30, 30, 30.256, 32.08, 38.128, 44.616, 52.912, 64.456,
        50, 50, 50, 50.32, 54.008, 59.808, 71.024, 88.184,
        90, 90, 90, 90, 90.448, 93.336, 101.536, 123.584,
        170, 170, 170, 170, 170, 170, 172.12, 185.672
    ]
)

inv_x1_cap_a = 1.00

# below LUTs are originally indexed by (input slew, output cap) with
# derate 0.5 from the simplified scc14nsfp lib.
# every number *=1000 to match the units.
# we then transpose it so it can be indexed by (output cap, input slew)
dqv1_ckq_cell_rise = LUT(
    xs=apply_derate([0.001, 0.00201845, 0.00407416, 0.0082235, 0.0165988, 0.0335039, 0.067626, 0.1365], 1000 * 0.5),
    ys=apply_derate([0.0002, 0.000479257, 0.00114844, 0.00275198, 0.00659452, 0.0158024, 0.0378669, 0.09074], 1000),
    vs=apply_derate([
        0.0250608, 0.0257499, 0.0271572, 0.0300063, 0.0361776, 0.0505771, 0.0849778, 0.167399,
        0.0254437, 0.0261339, 0.0275399, 0.030388, 0.0365599, 0.0509597, 0.0853604, 0.167801,
        0.0261988, 0.0268886, 0.0282951, 0.0311427, 0.0373122, 0.0517149, 0.086116, 0.168536,
        0.0275659, 0.0282563, 0.0296632, 0.0325101, 0.0386836, 0.0530846, 0.0875031, 0.169926,
        0.0299563, 0.0306471, 0.0320529, 0.0349028, 0.0410717, 0.0554797, 0.0898772, 0.172325,
        0.0338585, 0.0345488, 0.0359564, 0.0388034, 0.0449895, 0.0593888, 0.0938034, 0.176251,
        0.0393244, 0.0400153, 0.0414251, 0.0442754, 0.0504486, 0.0648726, 0.0992447, 0.18167,
        0.0465603, 0.0472499, 0.0486589, 0.0515182, 0.0576944, 0.0720933, 0.106485, 0.188959
    ], 1000)
).transpose()

dqv1_ckq_rise_trans = LUT(
    xs=apply_derate([0.001, 0.00201845, 0.00407416, 0.0082235, 0.0165988, 0.0335039, 0.067626, 0.1365], 1000 * 0.5),
    ys=apply_derate([0.0002, 0.000479257, 0.00114844, 0.00275198, 0.00659452, 0.0158024, 0.0378669, 0.09074], 1000),
    vs=apply_derate([
        0.00407506, 0.00476531, 0.00636569, 0.0103654, 0.02066, 0.0461076, 0.107401, 0.254178,
        0.0040746, 0.00476635, 0.00636282, 0.0103648, 0.0206599, 0.0461071, 0.107401, 0.254212,
        0.00407499, 0.00476779, 0.00636545, 0.0103755, 0.0206512, 0.0461065, 0.107401, 0.254175,
        0.00407938, 0.00477059, 0.00637119, 0.0103641, 0.0206639, 0.0461067, 0.10734, 0.254212,
        0.00407788, 0.00477218, 0.00637649, 0.0103785, 0.0206528, 0.0460876, 0.1074, 0.254214,
        0.00409104, 0.00477999, 0.00637958, 0.0103684, 0.0206736, 0.0461505, 0.107703, 0.254265,
        0.00411883, 0.00480275, 0.00639598, 0.0103803, 0.020654, 0.0460882, 0.107391, 0.254159,
        0.00417021, 0.00485767, 0.00643509, 0.0104207, 0.0206647, 0.0460936, 0.107309, 0.254667
    ], 1000 * 0.5)
).transpose()

invizn_cell_rise = LUT(
    xs=apply_derate([0.001, 0.00222855, 0.00496646, 0.011068, 0.0246657, 0.0549688, 0.122501, 0.273], 1000 * 0.5),
    ys=apply_derate([0.0002, 0.000469619, 0.00110271, 0.00258927, 0.00607985, 0.0142761, 0.0335216, 0.0787119], 1000),
    vs=apply_derate([
        0.0028297, 0.00328936, 0.00429382, 0.00654938, 0.0117614, 0.0239432, 0.0525464, 0.119654,
        0.00309733, 0.00358775, 0.00464021, 0.00694249, 0.0121732, 0.0243692, 0.0529696, 0.120034,
        0.00365774, 0.004191, 0.00533489, 0.00777698, 0.0131248, 0.0253668, 0.0539501, 0.121055,
        0.00442602, 0.0051712, 0.00663389, 0.00935501, 0.0150421, 0.0275757, 0.0561857, 0.123302,
        0.00527511, 0.0062805, 0.00829339, 0.0120376, 0.0186025, 0.0318485, 0.0611389, 0.128441,
        0.00601402, 0.00737947, 0.0101384, 0.0152789, 0.024425, 0.0399258, 0.0709219, 0.13942,
        0.00594708, 0.00785764, 0.011702, 0.0187559, 0.0313857, 0.0529389, 0.0890722, 0.161528,
        0.00339813, 0.00603442, 0.0112981, 0.0212641, 0.0387142, 0.0685149, 0.118686, 0.202465
    ], 1000)
).transpose()

invizn_rise_trans = LUT(
    xs=apply_derate([0.001, 0.00222855, 0.00496646, 0.011068, 0.0246657, 0.0549688, 0.122501, 0.273], 1000 * 0.5),
    ys=apply_derate([0.0002, 0.000469619, 0.00110271, 0.00258927, 0.00607985, 0.0142761, 0.0335216, 0.0787119], 1000),
    vs=apply_derate([
        0.00228675, 0.00298584, 0.00464049, 0.00856881, 0.0178068, 0.0394524, 0.0903672, 0.209921,
        0.00243498, 0.0031237, 0.00476538, 0.00862521, 0.0177875, 0.0394933, 0.0903637, 0.209821,
        0.00282887, 0.00345102, 0.00509423, 0.00892766, 0.017958, 0.039506, 0.0904149, 0.209988,
        0.00424444, 0.00493456, 0.00630828, 0.0097069, 0.018701, 0.0399167, 0.0904226, 0.20995,
        0.00638979, 0.00733244, 0.00924207, 0.0129016, 0.0206361, 0.0415524, 0.0912044, 0.210026,
        0.0100217, 0.0112641, 0.0139246, 0.0188242, 0.027776, 0.045875, 0.0949426, 0.211686,
        0.0161768, 0.018147, 0.0218375, 0.0285763, 0.0407052, 0.0618945, 0.104735, 0.219742,
        0.0265207, 0.0294661, 0.0351794, 0.0453198, 0.0619753, 0.0906886, 0.140144, 0.240648
    ], 1000 * 0.5)
).transpose()
